# 第01节：常量变量与解构赋值

### 一、ECMAscript概述

ECMAscript简称ES，是JavaScript的标准，我们经常说的ES5，ES6等等，可以称作JavaScript的版本，我们在之前学过的所有JavaScript特性，都是基于ES5版本的，今天我们开始讲解的是ES6标准的特性。ES6已更名为ES2015，ES7等后续的版本，我们都可以统称为ES2015+

### 二、变量和常量

ES6 新增了let命令，用来声明变量。它的用法类似于var，但是所声明的变量，只在let命令所在的代码块内有效。我们之前一直使用var定义变量，在ES6版本中，我们可以使用let定义变量，下面我们来说说var与let的区别

**块级作用域**

ES5只有全局作用域和函数作用域，没有块级作用域的概念，这带来了很多不合理的场景。
实例代码如下:


``` js
for(var i = 0;i<10;i++){
    console.log(i); // 0-9
}
console.log(i);     // 10
```

因为没有块级作用域，所以我们在for语句的外面仍然能获取i的值，在实际开发中，这是一个不可理喻的场景，我们希望的是这个i只在for语句内有效，所以再ES6中添加了块级作用域的概念，我们可以用let声明变量，问题就解决了
实例代码如下:

``` js
for(let i = 0;i<10;i++){
    console.log(i); // 0-9
}
console.log(i);     // 报错 i is not defined
```

因为用let声明变量，变量只在块级作用域下有效，所以再for语句之外输出i会报错。另外，for循环还有一个特别之处，就是设置循环变量的那部分是一个父作用域，而循环体内部是一个单独的子作用域。

**不存在变量提升**
定义：函数声明和变量声明总是被JavaScript解释器隐式地提升(hoist)到包含他们的作用域的最顶端。
通过定义我们可以知道，只有变量的声明和函数的声明存在变量提升这一说，那么在ES2015+出现之前，JavaScript声明变量的方式是通过关键字var实现的，声明函数自然通过function啦，ES6中我们用let，const来声明变量和常量。
实例代码如下:

```js
    {
      console.log(a) // 报错，a is not defined
      let a=2;
    }
```
如果let存在变量提升，那么上述代码就相当于下面这样
```js
    {
      let a;
      console.log(a) //undefined
      a=2;
    }
```
由此可见，let并不存在变量提升。

**不允许重复声明**

实例代码如下:
``` js
var a = 10;
var a = 20;

let b = 10;
let b = 20;  //报错
```

多次声明是没有意义的，在ES6中，我们使用let声明变量限制了不能多次声明，如果多次声明同一个变量会报错。

**常量**

在ES6中，不仅有变量，还增加了常量的概念，我们用const声明常量，一旦声明，它的值就不能再改变
实例代码如下:

``` js
const PI = 3.1415926;
PI = 3                   //报错
```

我们说常量不能再改变，说的是不能重新为这个常量赋值，但是如果常量存储的是一个对象，那我们是可以改变这个对象的属性的
实例代码如下:

``` js
const obj = {name:'小明'};
obj.name = '小红';
console.log(obj.name);   //小红
```


### 二、解构赋值

ES6允许按照一定模式，从数组和对象中提取值，对变量进行赋值，这被称为解构赋值，解构赋值主要包括数组的解构赋值、对象的解构赋值、字符串的解构赋值、函数参数的解构赋值。

**数组的结构赋值**

实例代码如下:

``` js
//传统赋值
var num1 = 1;
var num2 = 2;
var num3 = 3;

//数组的解构赋值
let [str1,str2,str3] = ["hello","world","javascript"];

console.log(str1);
console.log(str2);
console.log(str3);
```

**对象的解构赋值**
解构不仅可以用于数组，还可以用于对象。
实例代码如下:
``` js
let {num1,num2} = {num1:100,num2:10};
console.log(num1);
console.log(num2);
```

对象的解构与数组有一个重要的不同。数组的元素是按次序排列的，变量的取值由它的位置决定；而对象的属性没有次序，变量必须与属性同名，才能取到正确的值。

**字符串的结构赋值**
字符串也可以解构赋值。这是因为此时，字符串被转换成了一个类似数组的对象
示例代码如下:
``` js
let [a,b,c,d,e] = "hello";
console.log(a);
console.log(b);
console.log(c);
console.log(d);
console.log(e);
// 类似数组的对象都有一个length属性，因此还可以对这个属性解构赋值。
let {length : len} = 'hello'; 
//{length : len} length是长度的意思，len 是 let 声明的一个常量
console.log(len) //长度为数字的5
```


**函数参数的结构赋值**
函数的参数也可以使用解构赋值。
实例代码如下:

``` js
function add([x, y]){
  return x + y;
}

add([1, 2]); // 3

```
上面代码中，函数add的参数表面上是一个数组，但在传入参数的那一刻，数组参数就被解构成变量x和y。对于函数内部的代码来说，它们能感受到的参数就是x和y。






