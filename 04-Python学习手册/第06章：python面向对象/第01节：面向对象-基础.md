# 第01节：面向对象-基础

### 本节目标

- 理解面向对象
- 类和对象
- 添加和获取对象属性
- 魔法方法
### 一、理解面向对象
面向对象是一种抽象化的编程思想，很多编程语言中都有的一种思想。

例如：洗衣服

思考：几种途径可以完成洗衣服？

答： 手洗 和 机洗。

手洗：找盆 - 放水 - 加洗衣粉 - 浸泡 - 搓洗 - 拧干水 - 倒水 - 漂洗N次 - 拧干 - 晾晒。

机洗：打开洗衣机 - 放衣服 - 加洗衣粉 - 按下开始按钮 - 晾晒。

思考：对比两种洗衣服途径，你们发现了什么？

答：机洗更简单

思考：机洗，只需要找到一台洗衣机，加入简单操作就可以完成洗衣服的工作，而不需要关心洗衣机内部发生了什么事情。

> 总结：面向对象就是将编程当成是一个事物，对外界来说，事物是直接使用的，不用去管他内部的情况。而编程就是设置事物能够做什么事。
### 二、类和对象

思考：洗衣机洗衣服描述过程中，洗衣机其实就是一个事物，即对象，洗衣机对象哪来的呢？

答：洗衣机是由工厂工人制作出来。

思考：工厂工人怎么制作出的洗衣机？

答：工人根据设计师设计的功能图纸制作洗衣机。

总结：图纸  → 洗衣机 → 洗衣服。

在面向对象编程过程中，有两个重要组成部分：类 和 对象。

类和对象的关系：用类去创建一个对象。

### 三、面向对象实现方法
#### 1、定义类
- 语法

```python
class 类名():
    代码
    ......
```
> 注意：类名要满足标识符命名规则，同时遵循大驼峰命名习惯。

- 体验：  
``` python
class Washer(): 
    def wash(self):
        print('我会洗衣服')
```
> 对象里面的函数被称为方法/实例方法
#### 2、创建对象
对象又名实例。

- 语法

``` python
对象名 = 类名()
```
- 体验

``` python
# 创建类
class Washer(): 
    def wash(self):
        print('我会洗衣服')

# 创建对象
haier1 = Washer()


print(haier1) # 打印结果：# <__main__.Washer object at 0x0000018B7B224240>

# haier1对象调用实例方法
haier1.wash() # 打印结果：我会洗衣服
```

> 注意：创建对象的过程也叫实例化对象。
#### 3、self
self指的是调用该函数的对象。

``` python
# 1. 定义类
class Washer():
    def wash(self):
        print('我会洗衣服')
        print(self)


# 2. 创建对象方法
haier1 = Washer()
print(haier1) #  <__main__.Washer object at0x0000018B7B224240>

# haier1对象调用实例方法
haier1.wash() # <__main__.Washer object at0x0000018B7B224240>


# 由于打印对象和打印self得到的内存地址相同，所以self指定是调用该函数的对象
```
#### 4、创建多个对象
一个类是可以创建多个对象的。  

实例：  
``` python
class Aoo():
    def uzi(self):
        print('ADC')
        print(self)

# 对象1
lpl = Aoo() # <__main__.Aoo object at 0x00000210E8F7A708>
print(lpl)

# 对象2
ldl = Aoo()
print(ldl) # <__main__.Aoo object at 0x0000027BC66CE188>


#  两个对象的内存地址并不相同，所以验证了一个类是可以创建多个对象的
```
### 四、添加和获取对象属性
属性即是特征，比如：洗衣机的宽度、高度、重量...

对象属性既可以在类外面添加和获取，也能在类里面添加和获取。

#### 1、类外面添加对象属性

- 语法

``` python
对象名.属性名 = 值
```

- 体验

``` python
class Washer():
    def wash(self):
        print('我会洗衣服')
        print(self)

haier1 = Washer()

# 添加属性
# 给haier1添加了一个宽为500的属性
haier1 = width = 500
# 给haier1添加了一个高为800的属性
haier1 = height = 800
```
#### 2、类外面获取对象属性
- 语法

``` python
对象名.属性名
```

- 体验

``` python
class Washer():
    def wash(self):
        print('洗衣服')

haier1 = Washer()

haier1.width = 500
haier1.height = 800

print(f'haier1的宽度是{haier1.width}') # haier1的宽度是500
print(f'haier1的高度是{haier1.height}') # haier1的高度是800
```
#### 3、类里面获取对象属性

- 语法

``` python
self.属性名
```

- 体验

``` python
# 定义类
class Washer():
    def print_info(self):
        # 类里面获取实例属性
        print(f'haier1洗衣机的宽度是{self.width}')
        print(f'haier1洗衣机的高度是{self.height}')

# 创建对象
haier1 = Washer()

# 添加实例属性
haier1.width = 500
haier1.height = 800

# 调用类里面的方法
haier1.print_info()
```


### 五、魔法方法

在Python中，`__xx__()`的函数叫做魔法方法，指的是具有特殊功能的函数。

#### 1、__init__()

- 体验`__init__()`

思考：洗衣机的宽度高度是与生俱来的属性，可不可以在生产过程中就赋予这些属性呢？

答：理应如此。

`__init__()`方法的作用：初始化对象。（设置初始化属性）

实例：   
``` python
class Washer():

    # 定义初始化功能的函数
    def __init__(self):
        # 添加实例属性
        self.width = 500
        self.height = 800

    def print_info(self):
        # 类里面调用实例属性
        print(f'洗衣机的宽度是{self.width}, 高度是{self.height}')


haier1 = Washer()
# 可以直接调用类里面的方法，说明初始化添加的属性是有效的
haier1.print_info()
```
> 注意：
>
> - `__init__()`方法，在创建一个对象时默认被调用，不需要手动调用
> - `__init__(self)`中的self参数，不需要开发者传递，python解释器会自动把当前的对象引用传递过去。
#### 2、带参数的init
需求：把宽高设置为参数，不写固定的值

实例：   
``` python
class Washer():
    # 定义类：带参数的init
    def __init__(self, width, height):
        self.width = width
        self.height = height

    def print_info(self):
        print(f'洗衣机的宽度是{self.width}')
        print(f'洗衣机的高度是{self.height}')


# 创建多个对象且属性值不同：调用实例方法
haier1 = Washer(10, 20)
haier1.print_info()


haier2 = Washer(30, 40)
haier2.print_info()
```
#### 2、str
当使用print输出对象的时候，默认打印对象的内存地址。如果类定义了`__str__`方法，那么就会打印从在这个方法中 return 的数据。  

实例：  
``` python
class Washer():
    def __init__(self, width, height):
        self.width = width
        self.height = height

    def __str__(self):
        return '这是海尔洗衣机的说明书'


haier1 = Washer(10, 20)
# 这是海尔洗衣机的说明书
print(haier1)

```
#### 3、del

当删除对象时，python解释器也会默认调用`__del__()`方法。

实例：   
``` python
class Washer():
    def __init__(self, width, height):
        self.width = width
        self.height = height

    def __del__(self):
        print('对象已经被删除')


haier1 = Washer(10, 20) # 打印结果：对象已被删除
```
### 六、综合案例 --- 烤地瓜
#### 1、需求
需求主线：

 1. 被烤的时间和对应的地瓜状态：

    0-3分钟：生的

    3-5分钟：半生不熟

    5-8分钟：熟的

    超过8分钟：烤糊了

    

 2. 添加的调料：

    用户可以按自己的意愿添加调料
#### 2、步骤分析
需求涉及一个事物： 地瓜，故案例涉及一个类：地瓜类。
#### 3、定义类
- 地瓜的属性
  - 被烤的时间
  - 地瓜的状态
  - 添加的调料
- 地瓜的方法
  - 被烤
    - 用户根据意愿设定每次烤地瓜的时间
    - 判断地瓜被烤的总时间是在哪个区间，修改地瓜状态
  - 添加调料
    - 用户根据意愿设定添加的调料
    - 将用户添加的调料存储

- 显示对象信息
#### 4、代码实现

1. 定义类
- 地瓜属性
  - 定义地瓜初始化属性，后期根据程序推进更新实例属性
``` python
class SweetPotato():
    def __init__(self):
        # 被烤的时间
        self.cook_time = 0
        # 地瓜的状态
        self.cook_static = '生的'
        # 调料列表
        self.condiments = []
```
2. 定义烤地瓜方法
``` python
class SweetPotato():
    ......
    
    def cook(self, time):
        """烤地瓜的方法"""
        self.cook_time += time
        if 0 <= self.cook_time < 3:
            self.cook_static = '生的'
        elif 3 <= self.cook_time < 5:
            self.cook_static = '半生不熟'
        elif 5 <= self.cook_time < 8:
            self.cook_static = '熟了'
        elif self.cook_time >= 8:
            self.cook_static = '烤糊了'
```
3. 书写str魔法方法用于输出对象状态
``` python
class SweetPotato():
		......

    def __str__(self):
        return f'这个地瓜烤了{self.cook_time}分钟, 状态是{self.cook_static}'

```
4. 创建对象，测试实例属性和实例方法
``` python 
digua1 = SweetPotato()
print(digua1)
digua1.cook(2)
print(digua1)
```
5. 定义添加调料方法，并调用该方法
``` python
    def add_condiments(self, condiment):
        """添加调料"""
        self.condiments.append(condiment)
    def __str__(self):
        return f'这个地瓜烤了{self.cook_time}分钟, 状态是{self.cook_static}, 添加的调料有{self.condiments}'
      

digua1 = SweetPotato()
print(digua1)

digua1.cook(2)
digua1.add_condiments('酱油')
print(digua1)

digua1.cook(2)
digua1.add_condiments('辣椒面儿')
print(digua1)

digua1.cook(2)
print(digua1)

digua1.cook(2)
print(digua1)
```
6. 代码总览
``` python
# 定义类
class SweetPotato():
    def __init__(self):
        # 被烤的时间
        self.cook_time = 0
        # 地瓜的状态
        self.cook_static = '生的'
        # 调料列表
        self.condiments = []

    def cook(self, time):
        """烤地瓜的方法"""
        self.cook_time += time
        if 0 <= self.cook_time < 3:
            self.cook_static = '生的'
        elif 3 <= self.cook_time < 5:
            self.cook_static = '半生不熟'
        elif 5 <= self.cook_time < 8:
            self.cook_static = '熟了'
        elif self.cook_time >= 8:
            self.cook_static = '烤糊了'

    def add_condiments(self, condiment):
        """添加调料"""
        self.condiments.append(condiment)

    def __str__(self):
        return f'这个地瓜烤了{self.cook_time}分钟, 状态是{self.cook_static}, 添加的调料有{self.condiments}'


digua1 = SweetPotato()
print(digua1)

digua1.cook(2)
digua1.add_condiments('酱油')
print(digua1)

digua1.cook(2)
digua1.add_condiments('辣椒面儿')
print(digua1)

digua1.cook(2)
print(digua1)

digua1.cook(2)
print(digua1)
```

### 八、总结

- 面向对象重要组成部分 

  - 类
    - 创建类

  ``` python
  class 类名():
    代码
  ```

  - 对象

  ``` python
  对象名 = 类名()
  ```

- 添加对象属性

  - 类外面

  ``` python
  对象名.属性名 = 值
  ```

  - 类里面

  ``` python
  self.属性名 = 值
  ```

- 获取对象属性

  - 类外面

  ``` python
  对象名.属性名
  ```

  - 类里面

  ``` python
  self.属性名
  ```

- 魔法方法

  - `__init__()`: 初始化
  - `__str__()`:输出对象信息
  - `__del__()`:删除对象时调用


### 九、作业
#### 搬家具
根据需求尝试自己书写搬家具的代码，遇到不会的地方可以看一眼答案   

需求：将小于房子剩余面积的家具摆放到房子中    

步骤分析：  需求涉及两个事物：房子 和 家具，故被案例涉及两个类：房子类 和 家具类。    

定义类：  

- 房子类
  - 实例属性
    - 房子地理位置
    - 房子占地面积
    - 房子剩余面积
    - 房子内家具列表
  - 实例方法
    - 容纳家具
  - 显示房屋信息



- 家具类
  - 家具名称
  - 家具占地面积

参考答案：  
``` python
# 创建家具类：家具类里有家具的名字、家具的面积
class Jiaju():
    def __init__(self,name,area):
        self.name = name
        self.area = area
# 创建房屋类
class Home():
    def __init__(self,position,acreage):
        # 地理位置
        self.position = position
        # 房屋面积
        self.acreage = acreage
        # 剩余面积
        self.last = acreage
        # 家具列表
        self.list1 = []
    def __str__(self):
        return (f'房子的地理位置是{self.position},房子的面积是{self.acreage},剩余面积是{self.last},家具列表{self.list1}')
    # 容纳家具的函数
    def add_jiaju(self,item): # item形参用来接收家具
        if self.last > item.area: # if判断当剩余面积大于家具面积时，执行if下面的代码
            self.list1.append(item.name) # 给家具列表赋值，
            self.last -= item.area # 剩余面积 = 剩余面积 - 家具面积
        else:
            print('家具太大了放不进去')


bed = Jiaju('衣柜',5)
sf = Jiaju('沙发',20)
lqc = Jiaju('篮球场',2000)
jia = Home('北京',1200)


jia.add_jiaju(bed)
print(jia)
jia.add_jiaju(sf)
print(jia)
jia.add_jiaju(lqc)
print(jia)
```

















