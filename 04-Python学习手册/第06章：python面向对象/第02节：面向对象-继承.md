# 第02节：面向对象—继承

### 本节目标

- 继承的概念
- 单继承
- 多继承
- 子类重写父类的同名属性和方法
- 子类调用父类的同名属性和方法
- 多层继承
- super()
- 私有属性和私有方法

### 一、继承的概念
生活中的继承一般是指子女继承父母的财产。  
在python中继承的概念和生活中的继承可以说是一样的。   


python面向对象中的继承指的是多个类之间的关系，即子类默认继承父类的所有属性和方法，具体如下：  
``` python
# 父类
class Fu(object):  # object可以省略不写
    def __init__(self):
        self.num = 1
    def info_print(self):
        print(self.num)


# 子类
class Zi(Fu): # 括号填写你要继承的父类名字
    pass  # pass代表没有任何属性

# 创建对象验证结论
result = Zi() # 把子类赋值给result对象
result.info_print() # 打印结果为1，成功继承父类
```
> 在Python中，所有类默认继承object类(可以省略不写)，object类是顶级类或基类；其他子类叫做派生类。  
### 二、单继承
为了能够让大家更容易理解继承，我现在用一个故事配合实例来给大家讲解。  
> 故事主线：一个卖烤山药的老师傅，在烤山药界摸爬滚打多年，研发了一套精湛的烤山药技术。师父要把这套技术传授给他的唯一的最得意的徒弟。

实例：  
``` python
# 父类
class Shifu():
    def __init__(self):
        self.caipu = '[烤山药秘籍]'
    def aa(self):
        print(f'徒弟学会了{self.caipu}')
# 子类
class Tudi(Shifu):
    pass

# 创建对象result
result = Tudi()
# 对象访问实例属性
print(result.caipu)
# 对象访问实例方法
result.aa()
```
### 三、多继承
> 故事推进：bili是个爱学习的好孩子，想学习更多的烤山药技术，于是，在百度上报了一个烤山药培训班来学习烤山药。

所谓多继承意思就是一个类同时继承了多个父类。

实例：  
``` python
# 父类1
class Fu1():
    def __init__(self):
        self.kongfu = '[烤山药秘籍]'

    def make_cake(self):
        print(f'徒弟学会了{self.kongfu}')
# 父类2
class Fu2():
    def __init__(self):
        self.kongfu = '[培训班教的烤山药技术]'

    def make_cake(self):
        print(f'徒弟学会了{self.kongfu}')


class Prentice(Fu2, Fu1):
    pass


restule = Prentice()
print(restule.kongfu)
restule.make_cake()
```
> 注意：当一个类拥有多个父类时默认使用第一个父类的同名属性和方法
### 四、方法重写

如果你的父类方法的功能不能满足你的需求，你可以在子类重写你父类的方法，实例如下：  

实例：  
``` python
# 父类1
class Fu1():
    def __init__(self):
        self.kongfu = '[烤山药秘籍]'

    def make_cake(self):
        print(f'徒弟学会了{self.kongfu}')
# 父类2
class Fu2():
    def __init__(self):
        self.kongfu = '[培训班教的烤山药技术]'

    def make_cake(self):
        print(f'徒弟学会了{self.kongfu}')

# 子类里重写父类方法
class Prentice(Fu2, Fu1):
    def __init__(self):
        self.kongfu = '[bili独创烤山药技术]'

    def make_cake(self):
        print(f'徒弟学会了{self.kongfu}')

# 打印子类里重写的方法
restule = Prentice()
print(restule.kongfu) # [bili独创烤山药技术]
restule.make_cake() # 徒弟学会了[bili独创烤山药技术]
```
> 子类和父类拥有相同的属性和方法，默认使用子类的属性和方法
### 五、拓展 -- mro顺序

mro顺序可以让我们能够清楚的看到一个类都有哪些父类。  

实例：  
``` python
# 父类1
class Fu1():
    def __init__(self):
        self.kongfu = '[烤山药秘籍]'

    def make_cake(self):
        print(f'徒弟学会了{self.kongfu}')
# 父类2
class Fu2():
    def __init__(self):
        self.kongfu = '[培训班教的烤山药技术]'

    def make_cake(self):
        print(f'徒弟学会了{self.kongfu}')

# 子类
class Prentice(Fu2, Fu1):
    def __init__(self):
        self.kongfu = '[bili独创烤山药技术]'

    def make_cake(self):
        print(f'徒弟学会了{self.kongfu}')


restule = Prentice()
restule.make_cake()

# 查看子类Prentice的父类

print(Prentice.__mro__) # 打印结果：(<class '__main__.Prentice'>, <class '__main__.Fu2'>, <class '__main__.Fu1'>, <class 'object'>)

```
### 六、子类调用父类同名方法和属性
子类调用父类同名方法和属性：可以同调用子类和父类的同名方法。  

实例：     
``` python
# 父类1
class Fu1(object):
    def __init__(self):
        self.kongfu = '[老师傅的烤山药]'

    def make_cake(self):
        print(f'顾客购买{self.kongfu}')

# 父类2
class Fu2(object):
    def __init__(self):
        self.kongfu = '[培训班的烤山药]'

    def make_cake(self):
        print(f'顾客购买{self.kongfu}')

# 子类
class Prentice(Fu2,Fu1):
    def __init__(self):
        self.kongfu = '[bili独创烤山药]'

    def make_cake(self):
        # 如果是先调用了父类的属性和方法，父类属性会覆盖子类属性，所以在调用属性前，先调用自己子类的初始化
        self.__init__()
        print(f'顾客购买{self.kongfu}')

    # 子类调用父类的同名属性和方法：需要把父类的同名方法和属性再次封装
    def make_fu1_cake(self):
        # 再次调用初始化的原因这里想要调用父类1的同名方法和属性，属性在init初始化里面，所以要再次调用初始化化
        Fu1.__init__(self)
        Fu1.make_cake(self)

    def make_fu2_cake(self):
        Fu2.__init__(self)
        Fu2.make_cake(self)


bili = Prentice()
# 调用子类的make_cake方法
bili.make_cake()
# 调用父类的make_fu1_cake方法
bili.make_fu1_cake()
# 调用父类的make_fu2_cake方法
bili.make_fu2_cake()
# 再次调用子类的make_cake方法验证子类中调用init的作用
bili.make_cake()
```
### 七、多重继承

> 多年后bili老了，想把烤山药技术传给自己的徒弟aibi

实例：   
``` python
# 父类1
class Fu1(object):
    def __init__(self):
        self.kongfu = '[老师傅的烤山药]'

    def make_cake(self):
        print(f'顾客购买{self.kongfu}')

# 父类2
class Fu2(object):
    def __init__(self):
        self.kongfu = '[培训班的烤山药]'

    def make_cake(self):
        print(f'顾客购买{self.kongfu}')

# 子类
class Prentice(Fu2,Fu1):
    def __init__(self):
        self.kongfu = '[bili独创烤山药]'

    def make_cake(self):
        self.__init__()
        print(f'顾客购买{self.kongfu}')

    def make_fu1_cake(self):
        Fu1.__init__(self)
        Fu1.make_cake(self)

    def make_fu2_cake(self):
        Fu2.__init__(self)
        Fu2.make_cake(self)
# 1、创建孙子类
# 2、使用孙子类调用父类的属性和方法，测试能否成功调用
# 孙子类
class sun(Prentice):
    pass

aibi = sun()
# 调用子类内容
aibi.make_cake()
# 调用父类1的内容
aibi.make_fu1_cake()
# 调用父类2的内容
aibi.make_fu2_cake()
```
> 孙子类可调用父类的内容

### 八、super()调用父类方法

super()可以起到简到代码的效果，具体方法如下所示：  

实例：  
``` python
# 父类
class Fu(object):
    def __init__(self):
        self.kongfu = '[老师傅的烤山药]'

    def make_cake(self):
        print(f'顾客购买{self.kongfu}')

# 子类
class Zi(Fu):
    def __init__(self):
        self.kongfu = '[培训班的烤山药]'

    def make_cake(self):
        print(f'顾客购买{self.kongfu}')

        # # 方法二：Super带参数写法
        # super(Zi, self).__init__()
        # super(Zi, self).make_cake()

        # 方法二：无参数
        super().__init__()
        super().make_cake()


# 孙类
class Sun(Zi):
    def __init__(self):
        self.kongfu = '[bili独创烤山药]'

    def make_cake(self):
        self.__init__()
        print(f'顾客购买{self.kongfu}')
    # 需求：一次性调用爷爷类和父类的属性和方法
    def make_old_cake(self):
        # 方法一：如果定义的类名修改，这里也需要修改、代码量庞大，而且代码几乎都一样。
        # Fu.__init__(self)
        # Fu.make_cake(self)
        # Zi.__init__(self)
        # Zi.make_cake(self)

        # 方法二：Super()，带参数
        # 写法： super(当前类名, self).函数()
        # 如果想要打印爷爷类的内容需要在上面的zi类里也添加super方法
        # super(Sun, self).__init__()
        # super(Sun, self).make_cake()

        # 方法二：Super(),无参数  --- 以后在遇到子类调用情况时推荐使用此方法
        # 由于super方法只能调用到当前类的父类，所以我们需要在上面的子类也写上这super方法
        super().__init__()
        super().make_cake()

aibi = Sun()

aibi.make_old_cake()
```
### 九、私有权限
在Python中，可以为实例属性和方法设置私有权限，即设置某个实例属性或实例方法不继承给子类。   

设置私有权限的方法：在属性名和方法名 前面 加上两个下划线 __。例如：self.__name = '欣欣'是私有属性，sekf.name = '欣欣'不是私有属性。
def __method(self)是私有方法，def method(self)不是私有方法。  

#### 1、定义私有属性和方法
``` python
class Private():

   def __init__(self, name):

        self.name = name
        # 妹儿，今年多大了？
        self.__age = 18 # 私有属性

    # 定义私有方法
   def __method(self):
        print(f"我的年龄是{self.__age}")

xinxin = Private("欣欣")

# 打印私有属性，打印结果：不能打印，会报错
# print(xinxin.__age)

# 私有方法，打印结果：不能打印，会报错
# xinxin.__method()

# 非私有方法,可以正常打印
print(xinxin.name) # 欣欣
```
#### 2、访问私有属性值
在python中并没有正在意义上的私有，私有属性其实不过就是对名称做了一些特俗的处理，使外界无法访问到。  

访问私有属性方法：在调用的私有属性或方法前面加上一个  _类名就可以了。  

实例：  
``` python
class Private():

   def __init__(self, name):

        self.name = name
        # 妹儿，今年多大了？
        self.__age = 18 # 私有属性

    # 定义私有方法
   def __method(self):
        print(f"我的年龄是{self.__age}")

xinxin = Private("欣欣")

# 私有属性，加上_类名之后可以正常访问
print(xinxin._Private__age)

# 私有方法，加上_类名之后可以正常访问
xinxin._Private__method()

# 非私有方法,可以正常打印
print(xinxin.name) # 欣欣
```
### 十、总结

- 继承的特点

  - 子类默认拥有父类的所有属性和方法
  - 子类重写父类同名方法和属性
  - 子类调用父类同名方法和属性

- super()方法快速调用父类方法

- 私有权限

  - 不能继承给子类的属性和方法需要添加私有权限
  - 语法

  ``` python
  class 类名():
    # 私有属性
    __属性名 = 值
  
    # 私有方法
    def __函数名(self):
      代码
  ```


